{
  "name": "Nanotwitter",
  "tagline": "Implementation of a mini Twitter app",
  "body": "[ ![Codeship Status for kreddykhan/nanotwitter](https://codeship.com/projects/52e0fe00-909f-0134-b16b-6e4574ccc4bb/status?branch=master)](https://app.codeship.com/projects/185785)\r\n[ ![Heroku](https://heroku-badge.herokuapp.com/?app=kreddykhan-nanotwitter)](https://kreddykhan-nanotwitter.herokuapp.com)\r\n[ ![Code Climate](https://codeclimate.com/github/kreddykhan/nanotwitter/badges/gpa.svg)](https://codeclimate.com/github/kreddykhan/nanotwitter)\r\n\r\n#NanoTwitter\r\n\r\nNanoTwitter is an mini (or rather nano) implementation of Twitter done as part of the Brandeis Computer Science Software Engineering for Scalability course.\r\n\r\nThe point of the course was for students to implement an app using Ruby and Sinatra that allowed users to signup, login, tweet, follow other users and view other user's tweets and followers. Having completed these basic requirements, students then had to load test their apps and were encouraged to use techniques studied in class to better the quality of their scaling.\r\n\r\n##Team\r\n\r\nWhile the course is designed to be done in groups of three, I was the TA for the course as well as a student enrolled in the course and so attempted the assignment myself.\r\n\r\n##Screenshots\r\n\r\n##Technologies\r\n* Authentication\r\n* Codeship\r\n* Heroku\r\n* Web Servers\r\n* Redis\r\n* Loader.io\r\n\r\n##Interesting Engineering\r\n###Authentication\r\n\r\nThis was done using the BCrypt gem. What this essentially does is run the user entered password through a hash function and then stores it as a password_digest. When the user enters their password it is checked against the password_digest. Neither the password nor the password_digest can be accessed from the database which keeps the user credentials safe.\r\n\r\nSessions are then used to track the current user and thereby limit the current user privileges.\r\n\r\n###Codeship\r\n\r\nAn automatic deployment to Codeship was set up to ensure that all the tests ran and the app compiled successfully on a Virtual Machine. The badge at the top of the page shows that Codeship is currently passing everything.\r\n\r\n###Heroku\r\n\r\nHeroku is being used to host the app. The badge at the top of the page shows that it is currently successfully deployed and acts as a link to the app. The Heroku service requires PostgreSQL and for simplicity sake I chose to use it for both production and development. \r\n\r\nHeroku also provided us with a simple way to integrate a few of the scaling techniques described below.\r\n\r\n###Web Servers\r\n\r\nInitially I configured the app to run using Puma. I chose Puma because many of the introductory work I had done in Sinatra was in Puma. I had read that it was a better option than WEBrick, both because it was supposedly faster and it used concurrent threads.\r\n\r\nInitially I did not worry about the concurrency, but eventually I included a puma.rb in my config folder that set up worker threads. However, I have not been able to actually use these to my advantage.\r\n\r\nAfter some more research I found that Unicorn was apparently a much superior web server and so decided to switch to it. This required some further set up as Unicorn requires configuration files to ensure that it is not already started when the app is called and to have its timeouts set.\r\n\r\n###Redis\r\n###Loader.io\r\n\r\n##Result of scalability work, timings etc.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}