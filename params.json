{
  "name": "Nanotwitter",
  "tagline": "Implementation of a mini Twitter app",
  "body": "[ ![Codeship Status for kreddykhan/nanotwitter](https://codeship.com/projects/52e0fe00-909f-0134-b16b-6e4574ccc4bb/status?branch=master)](https://app.codeship.com/projects/185785)\r\n[ ![Heroku](https://heroku-badge.herokuapp.com/?app=kreddykhan-nanotwitter)](https://kreddykhan-nanotwitter.herokuapp.com)\r\n[ ![Code Climate](https://codeclimate.com/github/kreddykhan/nanotwitter/badges/gpa.svg)](https://codeclimate.com/github/kreddykhan/nanotwitter)\r\n\r\n#NanoTwitter\r\n\r\nNanoTwitter is an mini (or rather nano) implementation of Twitter done as part of the Brandeis Computer Science Software Engineering for Scalability course.\r\n\r\nThe point of the course was for students to implement an app using Ruby and Sinatra that allowed users to signup, login, tweet, follow other users and view other user's tweets and followers. Having completed these basic requirements, students then had to load test their apps and were encouraged to use techniques studied in class to better the quality of their scaling.\r\n\r\n##Team\r\n\r\nWhile the course is designed to be done in groups of three, I was the TA for the course as well as a student enrolled in the course and so attempted the assignment myself.\r\n\r\n##Screenshots\r\n\r\n##Technologies\r\n* Authentication\r\n* Codeship\r\n* Bootstrap\r\n* Heroku\r\n* Web Servers\r\n* Redis\r\n* Loader.io\r\n\r\n##Interesting Engineering\r\n###Authentication\r\n\r\nThis was done using the BCrypt gem. What this essentially does is run the user entered password through a hash function and then stores it as a password_digest. When the user enters their password it is checked against the password_digest. Neither the password nor the password_digest can be accessed from the database which keeps the user credentials safe.\r\n\r\nSessions are then used to track the current user and thereby limit the current user privileges.\r\n\r\n###Codeship\r\n\r\nAn automatic deployment to Codeship was set up to ensure that all the tests ran and the app compiled successfully on a Virtual Machine. The badge at the top of the page shows that Codeship is currently passing everything.\r\n\r\n###Bootstrap\r\n\r\nBootstrap was used for the UI.\r\n\r\n###Heroku\r\n\r\nHeroku is being used to host the app. The badge at the top of the page shows that it is currently successfully deployed and acts as a link to the app. The Heroku service requires PostgreSQL and for simplicity sake I chose to use it for both production and development. \r\n\r\nHeroku also provided us with a simple way to integrate a few of the scaling techniques described below.\r\n\r\n###Web Servers\r\n\r\nInitially I configured the app to run using Puma. I chose Puma because many of the introductory work I had done in Sinatra was in Puma. I had read that it was a better option than WEBrick, both because it was supposedly faster and it used concurrent threads.\r\n\r\nInitially I did not worry about the concurrency, but eventually I included a puma.rb in my config folder that set up worker threads. However, I have not been able to actually use these to my advantage.\r\n\r\nAfter some more research I found that Unicorn was apparently a much superior web server and so decided to switch to it. This required some further set up as Unicorn requires configuration files to ensure that it is not already started when the app is called and to have its timeouts set.\r\n\r\n###Redis\r\n\r\nI used Redis in order to cache the tweets that were displayed on the main NanoTwitter page. This made loading the page significantly easier as the tweets were pulled from the cache instead of being queried on every refresh.\r\n\r\nInitially I attempted to implement Redis using the redis gem and through my code on my local machine. This proved to be very difficult particularly because I was using Unicorn and Puma which were causing forking issues with Redis. This meant that even though I could run Redis, I could not run it on my app.\r\n\r\nEventually I found that it was possible to use Heroku to download and use a Redis client. This made it significantly easier as the client had all the necessary methods and it handled all the issues with forking for me.\r\n\r\nHaving implemented Redis I then used it to store a cache consisting of the 50 most recent tweets. The cache is given an expiration time of 60 seconds. If during that time the page is pinged, it checks whether the cache exists and if so simply loads it. If not it creates a new one. In this manner the load time after that initial cache store is significantly lower.\r\n\r\n###Loader.io\r\n\r\nLoader.io was used to test the loading abilities of the app. I configured loader.io to test the GET results of the main page, a user page, a user's tweet page, a user's follow page and the POST results of generating new users, new tweets, new followers.\r\n\r\n##Result of scalability work, timings etc.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}