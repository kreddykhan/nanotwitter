<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Nanotwitter by kreddykhan</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Nanotwitter</h1>
        <p>Implementation of a mini Twitter app</p>

        <p class="view"><a href="https://github.com/kreddykhan/nanotwitter">View the Project on GitHub <small>kreddykhan/nanotwitter</small></a></p>


        <ul>
          <li><a href="https://github.com/kreddykhan/nanotwitter/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/kreddykhan/nanotwitter/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/kreddykhan/nanotwitter">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><a href="https://app.codeship.com/projects/185785"> <img src="https://codeship.com/projects/52e0fe00-909f-0134-b16b-6e4574ccc4bb/status?branch=master" alt="Codeship Status for kreddykhan/nanotwitter"></a>
<a href="https://kreddykhan-nanotwitter.herokuapp.com"> <img src="https://heroku-badge.herokuapp.com/?app=kreddykhan-nanotwitter" alt="Heroku"></a>
<a href="https://codeclimate.com/github/kreddykhan/nanotwitter"> <img src="https://codeclimate.com/github/kreddykhan/nanotwitter/badges/gpa.svg" alt="Code Climate"></a></p>

<h1>
<a id="nanotwitter" class="anchor" href="#nanotwitter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NanoTwitter</h1>

<p>NanoTwitter is an mini (or rather nano) implementation of Twitter done as part of the Brandeis Computer Science Software Engineering for Scalability course.</p>

<p>The point of the course was for students to implement an app using Ruby and Sinatra that allowed users to signup, login, tweet, follow other users and view other user's tweets and followers. Having completed these basic requirements, students then had to load test their apps and were encouraged to use techniques studied in class to better the quality of their scaling.</p>

<h2>
<a id="team" class="anchor" href="#team" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Team</h2>

<p>While the course is designed to be done in groups of three, I was the TA for the course as well as a student enrolled in the course and so attempted the assignment myself.</p>

<h2>
<a id="screenshots" class="anchor" href="#screenshots" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Screenshots</h2>

<h2>
<a id="technologies" class="anchor" href="#technologies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Technologies</h2>

<ul>
<li>Authentication</li>
<li>Codeship</li>
<li>Bootstrap</li>
<li>Heroku</li>
<li>Web Servers</li>
<li>Redis</li>
<li>Loader.io</li>
</ul>

<h2>
<a id="interesting-engineering" class="anchor" href="#interesting-engineering" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Interesting Engineering</h2>

<h3>
<a id="authentication" class="anchor" href="#authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authentication</h3>

<p>This was done using the BCrypt gem. What this essentially does is run the user entered password through a hash function and then stores it as a password_digest. When the user enters their password it is checked against the password_digest. Neither the password nor the password_digest can be accessed from the database which keeps the user credentials safe.</p>

<p>Sessions are then used to track the current user and thereby limit the current user privileges.</p>

<h3>
<a id="codeship" class="anchor" href="#codeship" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Codeship</h3>

<p>An automatic deployment to Codeship was set up to ensure that all the tests ran and the app compiled successfully on a Virtual Machine. The badge at the top of the page shows that Codeship is currently passing everything.</p>

<h3>
<a id="bootstrap" class="anchor" href="#bootstrap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bootstrap</h3>

<p>Bootstrap was used for the UI.</p>

<h3>
<a id="heroku" class="anchor" href="#heroku" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Heroku</h3>

<p>Heroku is being used to host the app. The badge at the top of the page shows that it is currently successfully deployed and acts as a link to the app. The Heroku service requires PostgreSQL and for simplicity sake I chose to use it for both production and development. </p>

<p>Heroku also provided us with a simple way to integrate a few of the scaling techniques described below.</p>

<h3>
<a id="web-servers" class="anchor" href="#web-servers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Web Servers</h3>

<p>Initially I configured the app to run using Puma. I chose Puma because many of the introductory work I had done in Sinatra was in Puma. I had read that it was a better option than WEBrick, both because it was supposedly faster and it used concurrent threads.</p>

<p>Initially I did not worry about the concurrency, but eventually I included a puma.rb in my config folder that set up worker threads. However, I have not been able to actually use these to my advantage.</p>

<p>After some more research I found that Unicorn was apparently a much superior web server and so decided to switch to it. This required some further set up as Unicorn requires configuration files to ensure that it is not already started when the app is called and to have its timeouts set.</p>

<h3>
<a id="redis" class="anchor" href="#redis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Redis</h3>

<p>I used Redis in order to cache the tweets that were displayed on the main NanoTwitter page. This made loading the page significantly easier as the tweets were pulled from the cache instead of being queried on every refresh.</p>

<p>Initially I attempted to implement Redis using the redis gem and through my code on my local machine. This proved to be very difficult particularly because I was using Unicorn and Puma which were causing forking issues with Redis. This meant that even though I could run Redis, I could not run it on my app.</p>

<p>Eventually I found that it was possible to use Heroku to download and use a Redis client. This made it significantly easier as the client had all the necessary methods and it handled all the issues with forking for me.</p>

<p>Having implemented Redis I then used it to store a cache consisting of the 50 most recent tweets. The cache is given an expiration time of 60 seconds. If during that time the page is pinged, it checks whether the cache exists and if so simply loads it. If not it creates a new one. In this manner the load time after that initial cache store is significantly lower.</p>

<h3>
<a id="loaderio" class="anchor" href="#loaderio" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Loader.io</h3>

<p>Loader.io was used to test the loading abilities of the app. I configured loader.io to test the GET results of the main page, a user page, a user's tweet page, a user's follow page and the POST results of generating new users, new tweets, new followers.</p>

<h2>
<a id="result-of-scalability-work-timings-etc" class="anchor" href="#result-of-scalability-work-timings-etc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Result of scalability work, timings etc.</h2>

<h3>
<a id="initial-results" class="anchor" href="#initial-results" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Initial results</h3>

<p>Nov 28 12:51
Initially logging into the main page was the most difficult task. An attempt to do a maintain client load of 0-15 over 1 minute resulted in 2 successes, 3 timeouts in 10 seconds.</p>

<p>Logging into the user's home page was significantly easier. This was because this page had considerably fewer tweets that need to be parsed and presented to the viewer. An attempt to do a maintain client load of 0-15 over 1 minute resulted in 147 successes, 13 timeouts and all 15 clients being able to access the server at once.</p>

<p>Based on these tests I decided to switch to unicorn.</p>

<h3>
<a id="after-unicorn" class="anchor" href="#after-unicorn" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>After Unicorn</h3>

<p>While switching to Unicorn did not have a noticeable affect on the main page (it increased the successes to 3, but still timed out after 10 seconds), it did affect the user home page results. An attempt to do a maintain client load of 0-15 over 1 minute resulted in 952 successes, 0 timeouts and all 15 clients being able to access the server at once.</p>

<p>Having switched the web service I then proceeded onwards with the other tests. Loading the user follower and tweet pages were very straightforward and worked without any issues. There were no timeouts and they could maintain loads of 50.</p>

<p>The Generate Followers test was the easiest of the generation tests. This is because it simply establishes a relationship between two users and does not actually store anything in a database. This dramatically brings down the loading time. It was easily able to handle a load of 250 clients, requesting to have 30 followers each added and completed without timing out.</p>

<p>Generating Tweets and Users were more difficult because they do need to be added to the database which requires time. One way to handle this might be to use a cache to store new tweets and users and only add them to the database on refreshes or logins.</p>

<h3>
<a id="after-redis" class="anchor" href="#after-redis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>After Redis</h3>

<p>As of now the only part of the app that uses Redis is the main page. And it significantly improved the scaling abilities of it. With the caching the main page can handle a maintain client load of 0-500 over 1 minute with 1540 successes, 518 timeouts and all 500 clients being able to access the server at once.</p>

<h2>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Future Work</h2>

<p>Implement caching for the user and tweet generation.</p>

<p>Implement a microservice.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/kreddykhan">kreddykhan</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
